use super::*;
use crate::Crypto;

#[ttest]
async fn basic_test() {
    let backend = Crypto::new();

    let pair = backend.generate_pair().await.expect("Error generating key");

    let data = "This is some sample data".as_bytes();
    let signature = backend.sign(&pair, data).await.expect("Error signing");

    let pub_key = backend.import_pub(&backend.export_public_key(&pair)).await.expect("Error importing key");
    assert!(backend.verify(&pub_key, &signature, data).await);
}

#[ttest]
async fn fake_data_test() {
    let backend = Crypto::new();

    let pair = backend.generate_pair().await.unwrap();

    let data = "This is some sample data".as_bytes();
    let signature = backend.sign(&pair, data).await.unwrap();

    let pub_key = backend.import_pub(&backend.export_public_key(&pair)).await.unwrap();
    let data2 = "Whoops, this is different data!".as_bytes();
    assert!(!backend.verify(&pub_key, &signature, data2).await);
}

#[ttest]
async fn fake_key_import() {
    let backend = Crypto::new();

    let key_data = "Wait, this is garbage!".as_bytes();
    assert!(backend.import_pub(key_data).await.is_err());
}

#[ttest]
async fn verify_and_hash_test() {
    let backend = Crypto::new();
    let signed_data = "This data will be signed and verified".as_bytes();

    /* // Generator
    let pair = backend.generate_pair().await.unwrap();
    let signed = backend.sign(&pair, signed_data).await.unwrap();
    let pubkey = backend.export_public_key(&pair);
    panic!("pub: {}, sig: {}", hex::encode(pubkey), hex::encode(signed));*/

    // Generated by native environment
    let pub_key_data = hex::decode("046ea06f81f4bc71b7e506f8dd954c217e3221f870001560355c0432953ec6ff5b84884cb3e202e3db9e00ca0b8cd1341a572ed4f8acdf4abf67bdb57fa8eeac0c").unwrap();
    let signature = hex::decode("c1fbca2267806f7a2505e15c0fc0e5eb180bc38953a0cf5954e713a5ae6534fd6be545322a7eccf47da4dc601b361c2a0e5a6141b467f958da5229e9d4ef749e").unwrap();

    let pub_key = backend.import_pub(&pub_key_data).await.unwrap();
    assert!(backend.verify(&pub_key, &signature, signed_data).await);

    let hash = backend.hash(&pub_key_data).await.expect("Hashing failed");
    assert!(hex::encode(hash) == "1783119fcd8f4ed68342725c407ad22ffa5ef038f08a4c04a67aca0fe29e61ba");
}

#[ttest]
async fn verify_and_hash_test2() {
    let backend = Crypto::new();
    let signed_data = "This data will be signed and verified".as_bytes();

    // Generated by firefox
    let pub_key_data = hex::decode("041ea32bd1843dfb5da447ffebaaf6a353d8029323acab6cee78ce1c4c4f28a866c388778fbdc6836ad217b2fca7d892d2feb3d3232016b0e908e5d41618be060f").unwrap();
    let signature = hex::decode("8506c3fa99ffd5ac7cf983a4e4900921962b184d4ee2e6d768321057704fb1b3a23f63093d362325012ecda884c37e3291d880209c5e66201ab2a923cf0cfe51").unwrap();

    let pub_key = backend.import_pub(&pub_key_data).await.unwrap();
    assert!(backend.verify(&pub_key, &signature, signed_data).await);

    let hash = backend.hash(&pub_key_data).await.expect("Hashing failed");
    assert!(hex::encode(hash) == "926c54a654215c1cefbf01812239bfb835ee77abd6bb6a81c294ca37103309ee");
}
