use crate::*;
use super::ttest;

const CONTEXT: &'static [u8] = b"Some bit of context";

#[ttest]
async fn basic_test() {
    let pair = generate_pair().await.expect("Error generating key");

    let data = "This is some sample data".as_bytes();
    let signature = sign(&pair, data).await.expect("Error signing");

    let pub_key = import_pub_key(export_public_key(&pair)).await.expect("Error importing key");
    assert!(verify(&pub_key, &signature, data).await);
}

#[ttest]
async fn fake_data_test() {
    let pair = generate_pair().await.unwrap();

    let data = "This is some sample data".as_bytes();
    let signature = sign(&pair, data).await.unwrap();

    let pub_key = import_pub_key(&export_public_key(&pair)).await.unwrap();
    let data2 = "Whoops, this is different data!".as_bytes();
    assert!(!verify(&pub_key, &signature, data2).await);
}

#[ttest]
async fn fake_key_import() {
    let key_data = "Wait, this is garbage!".as_bytes();
    assert!(import_pub_key(key_data).await.is_err());
}

#[ttest]
async fn verify_and_hash_test() {
    let signed_data = "This data will be signed and verified".as_bytes();

    // Generator
    /*let pair = generate_pair().await.unwrap();
    let signed = sign(&pair, signed_data).await.unwrap();
    let pubkey = export_public_key(&pair);
    panic!("pub: {}, sig: {}", hex::encode(pubkey), hex::encode(signed));*/

    // Generated by native environment
    let pub_key_data = hex::decode("046ea06f81f4bc71b7e506f8dd954c217e3221f870001560355c0432953ec6ff5b84884cb3e202e3db9e00ca0b8cd1341a572ed4f8acdf4abf67bdb57fa8eeac0c").unwrap();
    let signature = hex::decode("c1fbca2267806f7a2505e15c0fc0e5eb180bc38953a0cf5954e713a5ae6534fd6be545322a7eccf47da4dc601b361c2a0e5a6141b467f958da5229e9d4ef749e").unwrap();

    let pub_key = import_pub_key(&pub_key_data).await.unwrap();
    assert!(verify(&pub_key, &signature, signed_data).await);

    let hash = sha2_hash(&CONTEXT, &pub_key_data).await.expect("Hashing failed");
    assert!(hex::encode(hash) == "4bf8fe89edabad690009a3a02a00fc9b80d68293e314735e00e50b762ab95b6b");
}

#[ttest]
async fn verify_and_hash_test2() {
    let signed_data = "This data will be signed and verified".as_bytes();

    // Generated by firefox
    let pub_key_data = hex::decode("041ea32bd1843dfb5da447ffebaaf6a353d8029323acab6cee78ce1c4c4f28a866c388778fbdc6836ad217b2fca7d892d2feb3d3232016b0e908e5d41618be060f").unwrap();
    let signature = hex::decode("8506c3fa99ffd5ac7cf983a4e4900921962b184d4ee2e6d768321057704fb1b3a23f63093d362325012ecda884c37e3291d880209c5e66201ab2a923cf0cfe51").unwrap();

    let pub_key = import_pub_key(&pub_key_data).await.unwrap();
    assert!(verify(&pub_key, &signature, signed_data).await);

    let hash = sha2_hash(&CONTEXT, &pub_key_data).await.expect("Hashing failed");
    assert!(hex::encode(hash) == "ddc6c90b1238fab5663118e4b865eeb4430fce9f1f02ceae8fbd41b188799022");
}
